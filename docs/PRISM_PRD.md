### **[Product Requirements Document]**

## PRISM (Point-cloud & RGB Integrated Sensing Module)

---

### **1. 한 줄 요약 (One-liner)**

**C++ 기반 고성능 LiDAR-카메라 퓨전 엔진**: Ouster OS1-32 라이다 포인트를 96채널로 보간하고 듀얼 카메라 RGB 정보를 융합하여, 실시간(20Hz, <50ms 레이턴시)으로 고밀도 컬러 포인트클라우드를 생성합니다.

### **2. 핵심 목표 (Core Objective)**

- **가장 빠르고, 가장 안정적이며, 가장 촘촘한 컬러 포인트클라우드를 시스템의 다른 노드에 제공하는 것.**
- 기존 `FILC`의 아이디어를 계승 및 확장하여, 시스템의 모든 노드가 신뢰하고 사용할 수 있는 **'산업용 등급(Production-Grade)'의 포인트클라우드 강화(Enhancement) 패키지**를 개발합니다.

### **3. 기술 아키텍처 및 언어**

- **언어: C++**
  - **선택 이유:** 실시간 데이터 동기화, 다수의 행렬 연산 등 성능이 가장 중요한 저수준 데이터 처리를 담당하므로, C++과 Eigen 라이브러리를 통해 최고의 성능을 보장합니다.
- **형태: ROS 2 노드**
  - 독립적인 노드로 동작하며, 원본 센서 데이터를 입력받아 처리 후, 정제된 'Rich Point Cloud'를 토픽으로 발행합니다.

### **4. 입/출력 (Inputs & Outputs)**

- **구독 (Inputs):**
  1.  `라이다 원본 데이터`: `/ouster/points` (`sensor_msgs/msg/PointCloud2`) - 32채널, 20Hz
  2.  `카메라 1 원본 이미지`: `/usb_cam_1/image_raw/uncompressed` (`sensor_msgs/msg/Image`) - 640x360, 30Hz
  3.  `카메라 2 원본 이미지`: `/usb_cam_2/image_raw/uncompressed` (`sensor_msgs/msg/Image`) - 640x360, 30Hz
  4.  `캘리브레이션 파라미터`: CALICO 형식 YAML 파일에서 로드
      - `multi_camera_intrinsic_calibration.yaml`: 카메라 내부 파라미터 (K matrix, distortion coeffs)
      - `multi_camera_extrinsic_calibration.yaml`: 라이다-카메라 간 외부 변환 행렬 (4x4 transformation matrix) 

- **발행 (Outputs):**
  1.  **`고품질 융합 데이터` (`/ouster/points/colored`):**
      - **메시지 타입:** `sensor_msgs/msg/PointCloud2`
      - **내용:** `[x, y, z, intensity, r, g, b]` 구조를 가진 고밀도 컬러 포인트클라우드. 기존 PointCloud2 포맷에 RGB 필드를 추가하여 발행합니다.
      - **주기:** 20Hz (라이다 입력과 동기화)

### **5. 핵심 기능 및 단계별 구현 계획**

1.  **실시간 데이터 동기화 (Time Synchronization)**
    - `message_filters` 라이브러리를 사용하여 라이다와 카메라 토픽의 타임스탬프를 나노초(ns) 단위까지 정확하게 동기화합니다.

2.  **고성능 좌표 변환 (High-Performance Transformation)**
    - 사전 캘리브레이션된 extrinsic 변환 행렬과 `Eigen` 라이브러리를 사용하여 라이다 좌표계의 모든 포인트를 각 카메라 좌표계로 실시간 변환합니다.
    - CALICO에서 제공하는 4x4 변환 행렬을 직접 적용하여 tf2 의존성 없이 고속 처리가 가능합니다.

3.  **`FILC` 채널 보간 기능 내장 (Channel Interpolation)**
    - 기존에 구현된 `FILC` 알고리즘(improved_interpolation_node.cpp)을 C++ 헤더 형태로 PRISM 프로젝트에 통합합니다.
    - Catmull-Rom 큐빅 보간을 사용하여 원본 32채널 데이터를 96채널(3배)의 촘촘한 데이터로 보간합니다.
    - OS1-32 고도각 정보를 활용한 정밀한 보간으로 포인트클라우드 밀도를 효과적으로 증가시킵니다.

4.  **포인트클라우드 컬러화 (Point Cloud Colorization)**
    - 보간을 통해 밀도가 높아진 포인트클라우드를 두 카메라 이미지 평면에 투영합니다.
    - 각 포인트에 해당하는 픽셀 좌표에서 서브픽셀 정밀도로 RGB 값을 추출합니다.
    - 멀티 카메라 융합: 두 카메라에서 모두 보이는 포인트는 거리 기반 가중치 블렌딩을 적용합니다.
    - 프러스텀 컬링과 오클루전 처리로 유효한 포인트만 컬러화합니다.

5.  **전용 토픽 발행 (Publisher)**
    - 위 모든 과정을 거쳐 완성된 최종 결과물, 즉 고밀도 컬러 포인트클라우드를 `/ouster/points/colored` 토픽에 발행합니다.


### **6. 상세 개발 명세 (Detailed Technical Specifications)**

이 섹션은 PRISM 패키지의 구체적인 기술 구현 사항을 문서화합니다. 각 문서는 프로덕션 레벨의 C++ 구현을 위한 상세한 가이드를 제공합니다.

#### **기술 문서 목록**

1. **[시스템 아키텍처](./architecture.md)**
   - 전체 시스템 구조 및 컴포넌트 다이어그램
   - 데이터 플로우 설계
   - 모듈별 상세 설계 및 인터페이스 명세
   - 성능 최적화 계획 및 개발 로드맵

2. **[패키지 구조 가이드](./package_structure.md)**
   - 디렉토리 구조 및 모듈 책임
   - 헤더 파일 아키텍처와 의존성 관리
   - CMakeLists.txt 구성 및 빌드 시스템
   - 테스팅 프레임워크 설정

3. **[보간 로직 통합 가이드](./interpolation_integration.md)**
   - FILC 보간 알고리즘 분석 및 통합 전략
   - OS1-32 빔 고도각 처리
   - SIMD 최적화 및 벡터화
   - 메모리 효율적 보간 파이프라인

4. **[투영 및 컬러 매핑 가이드](./projection_color_mapping.md)**
   - 카메라-라이다 좌표 변환
   - 3D→2D 투영 알고리즘
   - RGB 추출 및 서브픽셀 보간
   - 멀티 카메라 융합 전략

5. **[성능 최적화 가이드](./performance_optimization.md)**
   - TBB 기반 멀티스레딩 아키텍처
   - 메모리 풀 관리 및 제로카피 전략
   - SIMD 벡터화 및 캐시 최적화
   - 실시간 제약 및 레이턴시 관리

### **7. 기대 효과 및 가치 제안**

- 이 패키지만 독립적으로 실행해도, RViz에서 `/ouster/points/colored` 토픽을 구독하는 것만으로 주변 환경이 컬러풀한 3D 포인트클라우드로 렌더링되는, 그 자체로 매우 강력한 시각화 및 디버깅 툴이 됩니다.
- 후속 개발될 모든 인지/판단 알고리즘(HELIOS, FRONTIER 등)의 개발 복잡도를 낮추고, 성능의 기반을 다지는 핵심적인 역할을 수행합니다.

---

## **8. 개선 제안사항 (Enhancement Suggestions)**

### **성능 및 확장성 개선**

1. **다중 카메라 지원** (폐기됨. 오직 2개의 카메라만 지원하면 됨.)

2. **캘리브레이션 및 왜곡 처리** (굳이? 후순위 구현)
   - 카메라 왜곡 보정 파이프라인 (`image_geometry` 활용)
   - 정류된 이미지 사용 여부 명시
   - 온라인 캘리브레이션 검증 메커니즘

3. **데이터 최적화 및 성능 예산**
   - **성능 목표:** 
     - 입력 레이트: 20Hz (라이다), 30Hz (카메라)
     - 목표 지연: < 50ms
   - **최적화 전략:**
     - Voxel 다운샘플링 옵션 (0.05m 그리드)
     - ROI 기반 선택적 처리
     - PointCloud2 압축 전송 (PCL 압축 라이브러리)
     - QoS 설정: Best Effort, Durability Volatile

4. **RGB 필드 상세 명세**
   - RGB 패킹 형식: `rgb` float32 또는 `r,g,b` uint8
   - 색상 없는 포인트 처리: 기본값 (128, 128, 128) 또는 제거
   - frame_id 일관성 보장

5. **예외 처리 및 폴백**
   - 시야 외/후방 포인트 처리 정책
   - 카메라 데이터 누락 시 동작 모드
   - 동기화 실패 시 복구 메커니즘

### **KPI 및 수용 기준**
- 컬러화 정확도: 95% 이상 포인트 정확한 RGB 매칭
- 처리 지연: 평균 30ms, 최대 50ms
- 데이터 완전성: 입력 포인트의 98% 이상 처리
- 메모리 사용량: < 2GB

### **구현 우선순위 및 개발 로드맵**

#### **구현 상태 범례**
- 🔴 **TODO**: 미착수
- 🟡 **IN_PROGRESS**: 진행중  
- 🟢 **DONE**: 완료
- 🔵 **TESTING**: 테스트중
- ⚪ **OPTIONAL**: 선택사항

---

## **1. Phase 0: 프로젝트 기반 구축 (Week 0-1)** 🟢

### **1.1. 패키지 구조 설정** 🟢
#### **1.1.1. 디렉토리 구조 생성** 🟢
- **상태**: DONE
- **산출물**: 
  - `include/prism/` 헤더 디렉토리
  - `src/` 소스 디렉토리
  - `config/` 설정 파일 디렉토리
  - `launch/` 런치 파일 디렉토리
  - `test/` 테스트 디렉토리

#### **1.1.2. CMakeLists.txt 구성** 🔴
- **상태**: TODO
- **예상 시간**: 2시간
- **구현 내용**:
  ```cmake
  - ROS2 패키지 의존성 설정 (rclcpp, sensor_msgs, cv_bridge)
  - 외부 라이브러리 연결 (Eigen3, OpenCV, PCL, TBB)
  - 컴파일 옵션 설정 (-O3, -march=native, -fopenmp)
  - 설치 규칙 정의
  ```

#### **1.1.3. package.xml 작성** 🔴
- **상태**: TODO  
- **예상 시간**: 1시간
- **의존성 명시**:
  - 빌드 의존성: eigen3, libopencv-dev, libpcl-all-dev, libtbb-dev
  - 실행 의존성: sensor_msgs, geometry_msgs, std_msgs

### **1.2. 개발 환경 설정** 🔴
#### **1.2.1. 도커 환경 구성** ⚪
- **상태**: OPTIONAL
- **구현 내용**: 재현 가능한 빌드 환경을 위한 Dockerfile

#### **1.2.2. CI/CD 파이프라인** ⚪
- **상태**: OPTIONAL
- **구현 내용**: GitHub Actions 또는 GitLab CI 설정

---

## **2. Phase 1: 코어 인프라 구현 (Week 1-2)** 🔴

### **2.1. 메모리 관리 시스템** 🔴
#### **2.1.1. PointCloudSoA 데이터 구조** 🔴
- **상태**: TODO
- **예상 시간**: 4시간
- **구현 파일**: `include/prism/core/PointCloudTypes.hpp`
- **핵심 구현**:
  ```cpp
  - Structure-of-Arrays 레이아웃
  - SIMD 정렬 보장 (32바이트 경계)
  - 커스텀 할당자 지원
  ```

#### **2.1.2. 메모리 풀 구현** 🔴
- **상태**: TODO
- **예상 시간**: 6시간
- **구현 파일**: `include/prism/performance/MemoryPool.hpp`
- **핵심 기능**:
  - a. 고정 크기 블록 풀
  - b. Lock-free 할당/해제
  - c. NUMA 인식 할당
  - d. 통계 수집 기능

### **2.2. 캘리브레이션 관리자** 🔴
#### **2.2.1. YAML 파서 구현** 🔴
- **상태**: TODO
- **예상 시간**: 3시간
- **구현 파일**: `src/calibration_manager.cpp`
- **기능 명세**:
  - CALICO 형식 호환성 100%
  - 런타임 재로드 지원
  - 검증 및 에러 핸들링

#### **2.2.2. 변환 행렬 캐싱** 🔴
- **상태**: TODO
- **예상 시간**: 2시간
- **최적화**: Eigen 정렬 행렬 사용

### **2.3. 실행 모드 관리자** 🔴
#### **2.3.1. ExecutionMode 인터페이스** 🔴
- **상태**: TODO
- **예상 시간**: 4시간
- **구현 파일**: `include/prism/performance/ExecutionMode.hpp`
- **모드 구현**:
  - a. SingleThreadPipeline (디버그용)
  - b. CPUParallelPipeline (TBB)
  - c. GPUPipeline (CUDA/OpenCV)
  - d. AUTO 모드 선택 로직

---

## **3. Phase 2: 보간 엔진 구현 (Week 2-3)** 🔴

### **3.1. 기본 보간 알고리즘** 🔴
#### **3.1.1. FILC 로직 포팅** 🔴
- **상태**: TODO
- **예상 시간**: 8시간
- **구현 파일**: `src/interpolation_engine.cpp`
- **소스 참조**: `filc/src/improved_interpolation_node.cpp`
- **핵심 구현**:
  - a. OS1-32 고도각 테이블
  - b. Catmull-Rom 스플라인 구현
  - c. 불연속성 감지 알고리즘

#### **3.1.2. 싱글스레드 구현** 🔴
- **상태**: TODO
- **예상 시간**: 4시간
- **검증 방법**: 
  - FILC 원본과 출력 비교
  - 포인트 밀도 증가율 검증 (3배)

### **3.2. 최적화된 보간** 🔴
#### **3.2.1. SIMD 벡터화** 🔴
- **상태**: TODO
- **예상 시간**: 6시간
- **구현 내용**:
  - a. AVX2 intrinsics 사용
    - 8개 포인트 동시 처리
    - 수평 연산 최소화
  - b. AVX-512 지원 (선택적)
  - c. 런타임 CPU 기능 감지

#### **3.2.2. 병렬 처리** 🔴
- **상태**: TODO
- **예상 시간**: 4시간
- **구현 방식**:
  - TBB parallel_for로 채널별 병렬화
  - 캐시 라인 고려한 작업 분할

### **3.3. GPU 보간 (선택적)** ⚪
#### **3.3.1. CUDA 커널 구현** ⚪
- **상태**: OPTIONAL
- **예상 시간**: 8시간
- **임계값**: 50,000 포인트 이상에서 활성화

---

## **4. Phase 3: 투영 엔진 구현 (Week 3-4)** 🔴

### **4.1. 기본 투영 파이프라인** 🔴
#### **4.1.1. 3D-2D 투영 구현** 🔴
- **상태**: TODO
- **예상 시간**: 6시간
- **구현 파일**: `src/projection_engine.cpp`
- **참조 코드**: `calico/src/utils/projection_utils.cpp`
- **핵심 로직**:
  - a. 외부 변환 적용 (4x4 행렬)
  - b. 내부 파라미터 적용 (K 행렬)
  - c. 왜곡 보정 (5 파라미터)

#### **4.1.2. 프러스텀 컬링** 🔴
- **상태**: TODO
- **예상 시간**: 3시간
- **최적화**: 
  - 조기 종료 조건
  - AABB 기반 사전 필터링

### **4.2. 듀얼 카메라 병렬 투영** 🔴
#### **4.2.1. 동시 투영 구현** 🔴
- **상태**: TODO
- **예상 시간**: 4시간
- **구현 방식**:
  - a. std::async로 비동기 실행
  - b. 결과 동기화 및 병합

#### **4.2.2. 유효성 검증** 🔴
- **상태**: TODO
- **예상 시간**: 2시간
- **검증 항목**:
  - 이미지 경계 체크
  - 깊이 값 검증 (z > 0)
  - 오클루전 처리

### **4.3. GPU 투영 가속** ⚪
#### **4.3.1. OpenCV GPU 활용** ⚪
- **상태**: OPTIONAL
- **예상 시간**: 4시간
- **구현 내용**:
  - cv::cuda::projectPoints 활용
  - 배치 처리 최적화

#### **4.3.2. CUDA 커널 구현** ⚪
- **상태**: OPTIONAL
- **예상 시간**: 8시간
- **최적화**:
  - 공유 메모리 활용
  - Warp 레벨 최적화

---

## **5. Phase 4: 색상 추출 및 융합 (Week 4-5)** 🔴

### **5.1. 색상 샘플링** 🔴
#### **5.1.1. 서브픽셀 보간** 🔴
- **상태**: TODO
- **예상 시간**: 4시간
- **구현 파일**: `src/color_extraction_engine.cpp`
- **보간 방식**:
  - a. Bilinear (기본)
  - b. Bicubic (고품질)
  - c. Nearest (고속)

#### **5.1.2. 배치 색상 추출** 🔴
- **상태**: TODO
- **예상 시간**: 3시간
- **최적화**:
  - 캐시 친화적 접근 패턴
  - 프리페칭 힌트

### **5.2. 멀티 카메라 융합** 🔴
#### **5.2.1. 가중치 계산** 🔴
- **상태**: TODO
- **예상 시간**: 4시간
- **가중치 요소**:
  - a. 투영 거리 (중심부 우선)
  - b. 입사각 (정면 우선)
  - c. 신뢰도 점수

#### **5.2.2. 색상 블렌딩** 🔴
- **상태**: TODO
- **예상 시간**: 3시간
- **블렌딩 모드**:
  - a. 가중 평균
  - b. 최대 신뢰도 선택
  - c. 중앙값 필터링

### **5.3. GPU 색상 처리** ⚪
#### **5.3.1. 텍스처 메모리 활용** ⚪
- **상태**: OPTIONAL
- **예상 시간**: 6시간
- **최적화**: 하드웨어 보간 활용

---

## **6. Phase 5: 시스템 통합 (Week 5-6)** 🔴

### **6.1. ROS2 노드 구현** 🔴
#### **6.1.1. 메시지 핸들러** 🔴
- **상태**: TODO
- **예상 시간**: 4시간
- **구현 파일**: `src/prism_node.cpp`
- **구독 토픽**:
  - `/ouster/points` (20Hz)
  - `/usb_cam_1/image_raw/uncompressed` (30Hz)
  - `/usb_cam_2/image_raw/uncompressed` (30Hz)

#### **6.1.2. 시간 동기화** 🔴
- **상태**: TODO
- **예상 시간**: 6시간
- **구현 방식**:
  - a. message_filters::TimeSynchronizer
  - b. 적응형 버퍼링
  - c. 타임스탬프 보정

#### **6.1.3. 발행자 구현** 🔴
- **상태**: TODO
- **예상 시간**: 2시간
- **발행 토픽**: `/ouster/points/colored`
- **QoS 설정**: Best Effort, Volatile

### **6.2. 런치 파일 작성** 🔴
#### **6.2.1. 기본 런치 파일** 🔴
- **상태**: TODO
- **예상 시간**: 2시간
- **구현 파일**: `launch/prism.launch.py`

#### **6.2.2. 파라미터 설정** 🔴
- **상태**: TODO
- **예상 시간**: 2시간
- **설정 파일**: `config/prism_params.yaml`

---

## **7. Phase 6: 성능 최적화 (Week 6-7)** 🔴

### **7.1. 프로파일링 및 분석** 🔴
#### **7.1.1. 성능 측정 도구** 🔴
- **상태**: TODO
- **예상 시간**: 4시간
- **도구 구현**:
  - a. 스테이지별 타이밍
  - b. 메모리 사용량 추적
  - c. 캐시 미스율 측정

#### **7.1.2. 병목 지점 식별** 🔴
- **상태**: TODO
- **예상 시간**: 4시간
- **분석 도구**:
  - perf
  - VTune
  - nvprof (GPU)

### **7.2. 최적화 구현** 🔴
#### **7.2.1. 캐시 최적화** 🔴
- **상태**: TODO
- **예상 시간**: 6시간
- **기법**:
  - a. 데이터 구조 패딩
  - b. 루프 타일링
  - c. 프리페칭

#### **7.2.2. 병렬화 튜닝** 🔴
- **상태**: TODO
- **예상 시간**: 4시간
- **조정 항목**:
  - 스레드 수
  - 작업 분할 크기
  - 스케줄링 정책

### **7.3. 적응형 품질 제어** 🔴
#### **7.3.1. 동적 품질 조정** 🔴
- **상태**: TODO
- **예상 시간**: 6시간
- **조정 파라미터**:
  - a. 보간 밀도 (1x/2x/3x)
  - b. 색상 보간 품질
  - c. 처리 영역 제한

#### **7.3.2. 레이턴시 모니터링** 🔴
- **상태**: TODO
- **예상 시간**: 3시간
- **모니터링 지표**:
  - 평균/최대 레이턴시
  - 프레임 드롭율
  - CPU/GPU 사용률

---

## **8. Phase 7: 테스트 및 검증 (Week 7-8)** 🔴

### **8.1. 단위 테스트** 🔴
#### **8.1.1. 보간 테스트** 🔴
- **상태**: TODO
- **예상 시간**: 4시간
- **테스트 항목**:
  - a. 정확도 검증
  - b. 경계 조건
  - c. 성능 벤치마크

#### **8.1.2. 투영 테스트** 🔴
- **상태**: TODO
- **예상 시간**: 4시간
- **테스트 항목**:
  - a. 투영 정확도
  - b. 왜곡 보정 검증
  - c. 프러스텀 컬링

#### **8.1.3. 융합 테스트** 🔴
- **상태**: TODO
- **예상 시간**: 4시간
- **테스트 항목**:
  - a. 색상 정확도
  - b. 블렌딩 품질
  - c. 엣지 케이스

### **8.2. 통합 테스트** 🔴
#### **8.2.1. End-to-End 테스트** 🔴
- **상태**: TODO
- **예상 시간**: 6시간
- **테스트 시나리오**:
  - a. 정상 동작
  - b. 센서 누락
  - c. 동기화 실패

#### **8.2.2. 성능 검증** 🔴
- **상태**: TODO
- **예상 시간**: 4시간
- **검증 기준**:
  - 레이턴시 < 50ms
  - CPU 사용률 < 30%
  - 메모리 < 2GB

### **8.3. 시스템 테스트** 🔴
#### **8.3.1. RViz 시각화** 🔴
- **상태**: TODO
- **예상 시간**: 2시간
- **검증 항목**: 컬러 포인트클라우드 렌더링

#### **8.3.2. Rosbag 재생 테스트** 🔴
- **상태**: TODO
- **예상 시간**: 4시간
- **테스트 데이터**: 다양한 환경 조건

---

## **9. Phase 8: 문서화 및 배포 (Week 8)** 🟢

### **9.1. 기술 문서** 🟢
#### **9.1.1. 아키텍처 문서** 🟢
- **상태**: DONE
- **산출물**: `docs/architecture.md`

#### **9.1.2. API 레퍼런스** 🔴
- **상태**: TODO
- **예상 시간**: 6시간
- **도구**: Doxygen

### **9.2. 사용자 문서** 🔴
#### **9.2.1. 설치 가이드** 🔴
- **상태**: TODO
- **예상 시간**: 2시간

#### **9.2.2. 사용 매뉴얼** 🔴
- **상태**: TODO
- **예상 시간**: 4시간

### **9.3. 배포 준비** 🔴
#### **9.3.1. 릴리즈 패키징** 🔴
- **상태**: TODO
- **예상 시간**: 2시간

#### **9.3.2. 버전 태깅** 🔴
- **상태**: TODO
- **버전**: v1.0.0

---

## **의존성 관계 다이어그램**

```
Phase 0 (기반구축)
    ↓
Phase 1 (코어인프라) ──→ Phase 2 (보간엔진)
    ↓                         ↓
Phase 3 (투영엔진) ←─────────┘
    ↓
Phase 4 (색상융합)
    ↓
Phase 5 (시스템통합)
    ↓
Phase 6 (성능최적화)
    ↓
Phase 7 (테스트검증)
    ↓
Phase 8 (문서화배포)
```

---

## **리스크 및 대응 방안**

### **기술적 리스크**
1. **레이턴시 목표 미달성**
   - 대응: 적응형 품질 제어로 동적 조정
   - 폴백: 싱글스레드 모드로 디버깅

2. **GPU 메모리 부족**
   - 대응: 스트리밍 처리 구현
   - 폴백: CPU 처리로 자동 전환

3. **센서 동기화 실패**
   - 대응: 적응형 버퍼 크기 조정
   - 폴백: 최근접 타임스탬프 매칭

### **일정 리스크**
1. **CUDA 개발 지연**
   - 대응: OpenCV GPU로 우선 구현
   - 폴백: CPU SIMD 최적화 집중

2. **테스트 데이터 부족**
   - 대응: 시뮬레이션 데이터 생성
   - 폴백: 단위 테스트 강화

---

## **성공 지표 (KPI)**

### **필수 달성 목표**
- ✅ 처리 레이턴시: < 50ms (95 percentile)
- ✅ CPU 사용률: < 30% (평균)
- ✅ 메모리 사용량: < 2GB
- ✅ 포인트 처리율: > 98%
- ✅ 색상 정확도: > 95%

### **추가 목표**
- ⭐ GPU 가속 시 10배 성능 향상
- ⭐ 100,000 포인트/프레임 처리 가능
- ⭐ 실시간 파라미터 조정 지원