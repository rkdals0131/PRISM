
### **상황별 개선 프롬프트 예시 (5가지)**

**예시 1: 고성능 컴퓨팅(HPC) 전문가에게 성능 병목 현상 예측을 요청**

> **역할:** 당신은 로보틱스 데이터 처리 파이프라인에 특화된 고성능 컴퓨팅(HPC) 아키텍트입니다. 특히 TBB(Threading Building Blocks)와 SIMD(AVX2)를 사용한 C++ 성능 최적화에 10년 이상의 경험이 있습니다.
>
> **맥락:** 현재 'PRISM'이라는 ROS2 패키지의 개발 계획 문서를 검토하고 있습니다. 이 패키지는 Ouster OS1-32 LiDAR(20Hz)와 듀얼 카메라(30Hz) 데이터를 융합하여 96채널 컬러 포인트클라우드를 50ms 미만의 지연 시간 내에 생성하는 것을 목표로 합니다. `performance_optimization.md` 문서에 따르면, TBB `task_arena`를 사용하여 보간, 투영, 색상 추출 작업을 분리하고, `Structure-of-Arrays(SoA)` 데이터 구조를 통해 SIMD 연산을 가속화할 계획입니다.
>
> **요청:**
> 1.  제안된 TBB `task_arena` 분리 구조가 실제 CPU 환경에서 L1/L2 캐시 경합(Cache Contention)이나 NUMA 아키텍처 비효율성을 야기할 잠재적 위험은 무엇입
> 2.  `SoA` 데이터 구조가 메모리 대역폭을 최적으로 활용하는 것은 맞지만, 각 파이프라인 단계(보간→투영→색상 추출)를 거치며 데이터의 재정렬이 필요할 때 발생하는 오버헤드를 어떻게 평가해야 합니까? AoSoA(Array of Structures of Arrays) 방식과 비교하여 현재 설계의 장단점을 분석해주세요.
> 3.  `performance_optimization.md`에 명시된 `Lock-Free Ring Buffer`가 두 처리 단계 사이의 데이터 전달에 사용될 때, 데이터 생산 속도(보간 스레드)와 소비 속도(투영 스레드)의 미세한 불일치가 누적되어 버퍼 오버런 또는 언더런을 일으킬 가능성을 분석하고, 이를 방지하기 위한 동적 스로틀링(throttling) 메커니즘을 제안해주세요.

*   **개선점:** 일반적인 "성능 검토"가 아닌, `TBB task_arena`, `SoA vs AoSoA`, `Cache Contention`, `Lock-Free Ring Buffer` 등 문서에 명시된 구체적인 기술 스택과 아키텍처의 잠재적 병목 현상을 예측하도록 매우 깊이 있는 질문을 던집니다.

---

**예시 2: 로보틱스 비전 과학자에게 알고리즘의 강건성(Robustness) 검토를 요청**

> **역할:** 당신은 다중 센서 캘리브레이션 및 3D 인식 분야의 선임 연구 과학자입니다. 특히 CALICO와 같은 오픈소스 캘리브레이션 툴의 내부 동작 방식과 실제 필드에서의 실패 사례(failure cases)에 대해 깊이 이해하고 있습니다.
>
> **맥락:** 'PRISM' 프로젝트는 `projection_color_mapping.md`에 기술된 바와 같이, CALICO 형식의 YAML 파일에서 카메라 내/외부 파라미터를 로드하여 사용합니다. 또한 `interpolation_integration.md`에서는 FILC에서 영감을 받은 Catmull-Rom 보간법으로 포인트 밀도를 높인 후, 서브픽셀 정밀도로 색상을 추출하는 것을 목표로 합니다.
>
> **요청:**
> 1.  정적(Static) 캘리브레이션 값에만 의존할 때, 주행 중 발생하는 미세한 진동이나 열팽창으로 인한 센서 간의 상대적 자세 변화가 최종 컬러 매핑 정확도에 미치는 영향을 정량적으로 예측해주세요. 이를 보완하기 위해 온라인(Online) 캘리브레이션 상태를 모니터링할 수 있는 간단한 'Health Check' 로직을 제안해주십시오.
> 2.  두 카메라의 시야가 겹치는 영역에서 '거리 기반 가중치 블렌딩'을 사용한다고 되어 있습니다. 하지만, 한쪽 카메라 렌즈에만 이물질(예: 빗방울, 먼지)이 묻었을 경우, 이 블렌딩 방식이 어떻게 잘못된 색상 정보를 생성할 수 있는지 설명하고, 이를 감지하고 해당 카메라의 가중치를 동적으로 낮추는 강건한 퓨전 전략을 제시해주세요.
> 3.  LiDAR 포인트가 객체의 경계면(예: 건물 모서리)에 위치할 때, Catmull-Rom 보간이 'overshooting' 현상을 일으켜 실제로는 존재하지 않는 '유령' 포인트를 생성할 수 있습니다. 이로 인해 배경색이 전경 객체에 스며드는 'Color Bleeding' 현상이 발생할 수 있는데, `interpolation_integration.md`에 기술된 단절성 감지(discontinuity detection) 로직 외에 이를 방지할 수 있는 추가적인 알고리즘 기법은 무엇이 있습니까?

*   **개선점:** 단순히 "알고리즘을 평가해달라"는 요청을 넘어, `온라인 캘리브레이션`, `센서 오염`, `보간 아티팩트` 등 실제 자율주행 환경에서 마주할 수 있는 극한의 예외 상황(corner cases)에 대한 알고리즘의 강건성을 검토하도록 유도합니다.

---

**예시 3: 숙련된 ROS2/C++ 개발자에게 소프트웨어 아키텍처 리뷰를 요청**

> **역할:** 당신은 대규모 상용 ROS2 시스템을 설계하고 리드한 경험이 풍부한 소프트웨어 아키텍트입니다. C++17 표준과 ROS2의 `rclcpp`, `component_composition` 메커니즘에 대한 깊은 이해를 보유하고 있습니다.
>
> **맥락:** 'PRISM' 패키지는 `package_structure.md`에 상세히 기술된 모듈형 구조를 따르고 있으며, `architecture.md`에서는 RAII 패턴을 활용한 메모리 풀과 다중 스레드 아키텍처를 제안합니다. 최종 산출물은 독립적인 ROS2 노드입니다.
>
> **요청:**
> 1.  `CMakeLists.txt` 구조와 `package.xml`의 의존성 설정을 검토했을 때, 이 패키지를 외부에 라이브러리 형태로 제공(`-lprism_core`)할 경우 발생할 수 있는 잠재적인 링크 문제나 의존성 충돌이 있는지 분석해주세요. 특히 PCL, OpenCV, TBB와 같은 대형 라이브러리와의 `find_package` 처리 방식에서 개선할 점이 있습니까?
> 2.  현재의 단일 노드(`PRISMFusionNode`) 아키텍처 대신, ROS2의 `Composable Nodes`를 활용하여 `InterpolationNode`, `ProjectionNode`, `FusionNode`로 기능을 분리하는 아키텍처의 장단점을 논해주세요. 특히, Zero-copy 데이터 전송이 가능한 `rclcpp::LoanedMessage`를 사용했을 때의 성능 이점과 아키텍처 복잡도 증가를 비교 분석해주세요.
> 3.  `architecture.md`에 제안된 `MemoryPool` 클래스는 `std::mutex`를 사용합니다. 높은 빈도(20Hz)로 대량의 포인트 클라우드 데이터가 처리되는 상황에서 이 뮤텍스가 경합의 원인이 될 가능성이 높습니다. 이를 `std::atomic`과 lock-free 자료구조를 사용하는 방식으로 전환할 때의 설계 변경 사항과 주의점을 코드 수준에서 제안해주십시오.

*   **개선점:** 기능 구현을 넘어, `CMake`, `Composable Nodes`, `Zero-copy`, `Lock-free` 등 ROS2와 C++의 고급 기능을 활용하여 패키지의 재사용성, 확장성, 유지보수성, 그리고 최고 수준의 성능을 달성하기 위한 소프트웨어 공학적 관점의 질문을 제시합니다.

---

**예시 4: GPU 가속 전문가에게 CUDA 전환 전략 검토를 요청**

> **역할:** 당신은 CPU 기반의 복잡한 컴퓨터 비전 알고리즘을 CUDA를 사용하여 GPU로 성공적으로 이식한 경험이 많은 GPU 가속 전문가입니다.
>
> **맥락:** `performance_optimization.md` 문서에는 TBB와 SIMD를 사용한 CPU 최적화 계획이 상세히 기술되어 있으며, 향후 GPU 가속(CUDA)을 선택적으로 고려할 수 있다고 언급되어 있습니다.
>
> **요청:**
> 1.  현재 제안된 `Structure-of-Arrays (SoA)` 데이터 레이아웃이 CUDA 커널로 데이터를 전달할 때 얼마나 효율적인지 평가해주세요. CUDA의 `coalesced memory access`를 극대화하기 위해 현재의 `PointCloudSoA` 구조를 수정하거나 보완해야 할 부분이 있습니까?
> 2.  전체 파이프라인(보간 → 변환 → 투영 → 색상 추출) 중에서 가장 GPU 가속 효과가 클 것으로 예상되는 단계를 2가지 선택하고, 그 이유를 연산 집약도(Arithmetic Intensity)와 데이터 병렬성(Data Parallelism) 관점에서 설명해주세요.
> 3.  CPU와 GPU를 함께 사용하는 이기종 컴퓨팅(Heterogeneous Computing) 환경을 가정할 때, CPU(TBB)와 GPU(CUDA Streams) 간의 효율적인 작업 분배 및 동기화 전략을 제안해주세요. 예를 들어, 보간은 CPU에서 수행하고 투영 및 색상 추출은 GPU에서 수행하는 파이프라인을 구성할 때 발생할 수 있는 PCIe 대역폭 병목 현상과 이를 최소화하기 위한 `Pinned Memory` 및 `Asynchronous Memcpy` 활용 방안을 설명해주세요.

*   **개선점:** 단순히 "GPU로 만들 수 있나요?"가 아니라, `메모리 접근 패턴`, `연산 집약도`, `이기종 컴퓨팅`, `PCIe 병목` 등 GPU 전문가만이 답변할 수 있는 구체적인 기술적 질문을 통해 CPU 아키텍처가 GPU로의 전환에 얼마나 적합한지, 그리고 그 전환 전략은 어떠해야 하는지 심도 있게 검토하도록 합니다.

---

**예시 5: 기술 프로젝트 매니저(TPM)에게 프로젝트 계획 검토를 요청**

> **역할:** 당신은 로보틱스 분야에서 여러 C++ 기반 고성능 센서 처리 모듈의 개발을 성공적으로 이끈 기술 프로젝트 매니저(TPM)입니다. 애자일 개발 방법론과 리스크 관리에 능숙합니다.
>
> **맥락:** `PRISM_PRD.md`와 `architecture.md`의 개발 로드맵에는 4단계(Phase 1~4)로 구성된 개발 계획과 기술적 리스크 및 완화 전략이 명시되어 있습니다.
>
> **요청:**
> 1.  제시된 개발 로드맵의 `Critical Path Analysis`가 '보간 → 투영 → 색상 추출 → 통합' 순으로 되어 있습니다. 그러나 실제로는 각 모듈의 단위 테스트보다 초기부터 End-to-End 통합 테스트(가짜 데이터라도 사용해서)를 먼저 구축하는 것이 전체 프로젝트 리스크를 줄이는 데 더 효과적일 수 있습니다. 이러한 관점에서 현재 로드맵을 재구성하고, 각 단계별 측정 가능한 결과물(Definition of Done)을 다시 정의해주세요.
> 2.  `PRISM_PRD.md`의 KPI(수용 기준)에 "처리 지연: 평균 30ms, 최대 50ms"가 명시되어 있습니다. 하지만 이 목표를 달성하기 위한 구체적인 성능 예산(Performance Budget)이 각 하위 모듈(보간, 동기화, 투영 등)에 할당되어 있지 않습니다. 각 모듈에 할당할 현실적인 시간 예산(ms)을 제안하고, 이 예산을 초과했을 때 어떤 기능부터 품질을 저하(graceful degradation)시켜야 할지 우선순위를 정해주세요.
> 3.  '리스크 완화 전략'에서 "Latency Target Miss: Implement progressive optimization with fallback algorithms"라고 다소 추상적으로 기술되어 있습니다. 50ms 목표 달성 실패 시 즉시 적용할 수 있는 구체적인 'Plan B'를 3가지 제시해주세요. (예: 보간 채널 수를 96에서 64로 동적 감소, Bilinear 색상 추출을 Nearest Neighbor로 전환, 두 번째 카메라 처리 임시 비활성화 등)

*   **개선점:** 코드의 기술적 측면을 넘어, `로드맵의 타당성`, `성능 예산 분배`, `구체적인 리스크 대응 계획` 등 프로젝트를 일정과 요구사항에 맞춰 성공적으로 완수하기 위한 프로젝트 관리 관점의 날카로운 질문을 통해 계획의 실현 가능성을 검증합니다.